#pragma config(Sensor, in6,    ,               sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorNone)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorNone)
#pragma config(Sensor, dgtl12, armEncoder,     sensorQuadEncoder)
#pragma config(Motor,  port2,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           rightMotor,    tmotorServoContinuousRotation, openLoop, encoder, encoderPort, dgtl1, 1000)
#pragma config(Motor,  port7,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed, encoder, encoderPort, dgtl3, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                - Clawbot Single Joystick Control -                                 *|
|*                                      ROBOTC on VEX 2.0 Cortex                                      *|
|*                                                                                                    *|
|*  This program uses a single joystick, either right or left to drive the robot. Use notes below     *|
|*  to reconfigure which joystick is used. The joystick buttons are used to raise and lower the arm.	*|
|*  The joystick buttons are used to open and close the claw.																					*|
|*																																																		*|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)	Ch1 is the X axis and Ch2 is the Y axis for the RIGHT joystick.                             *|
|*    2)	Ch3 is the Y axis and Ch4 is the X axis for the LEFT joystick.                              *|
|*		3)	Button 5U and 5L are on the front left side of the joystick.																*|
|*		3)	Button 6U and 6L are on the front right side of the joystick.																*|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]        [Name]          [Type]                               [Description]            *|
|*    Motor - Port 2   rightMotor    VEX 393 Motor                         Right drive motor          *|
|*    Motor - Port 6   clawMotor     VEX 393 Motor w/ Motor Controler 29   Claw motor                 *|
|*    Motor - Port 7   armMotor      VEX 393 Motor w/ Motor Controler 29   Arm motor                  *|
|*    Motor - Port 10  leftMotor     VEX 393 Motor                         Left drive motor           *|
\*----------------------------------------------------------------------------------------------------*/
//++++++++++++++++++++++++| BEYGJA EFTIR BRAUT |+++++++++++++++++++++++++++++
void driveForward(int forwardtime)
{
		while(SensorValue[leftEncoder] > forwardtime)  // While less than 5 rotations on the leftEncoder...
  	{
  			if(SensorValue[rightEncoder] == SensorValue[leftEncoder])
  			{
  				motor[rightMotor] = 60;
  				motor[leftMotor] = 60;
  			}
  			else if(SensorValue[rightEncoder] > SensorValue[leftEncoder])
  			{
  				motor[rightMotor] = 60;
  				motor[leftMotor] = 80;
  			}
  			else
  			{
  				motor[rightMotor] = 80;
  				motor[leftMotor] = 60;
  			}
  	}
}

void clearEncoder()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
}

void stopMotor()
{
	motor[rightMotor] = 0;
 	motor[leftMotor]  = 0;
 	wait1Msec(1000);  // 1 Second Delay
}

void rightTurn90()
{
	motor[leftMotor] = 60;
	motor[rightMotor]= -60;

	 while(SensorValue[rightEncoder] < 207 || SensorValue[leftEncoder] > -207)
	 {
    if(SensorValue[rightEncoder] > 207) {motor[rightMotor] = 0;}
    if(SensorValue[leftEncoder] < -207) {motor[leftMotor] = 0;}
   }
}
void leftTurn90()
{
	motor[leftMotor] = -60;
	motor[rightMotor]= 60;

	 while(SensorValue[rightEncoder] > -207 || SensorValue[leftEncoder] < 207)
	  {
    if(SensorValue[rightEncoder] > 207) {motor[rightMotor] = 0;}
    if(SensorValue[leftEncoder] < -207) {motor[leftMotor] = 0;}
    }
}


task drive()
{
			clearEncoder();

			driveForward(-564);

			stopMotor();

 			clearEncoder();

 			leftTurn90();

			stopMotor();

 			clearEncoder();

 			driveForward(-564);

 			stopMotor();

 			clearEncoder();

 			rightTurn90();

 			stopMotor();

 			clearEncoder();

 			driveForward(-564);

 			stopMotor();

 			clearEncoder();

 			rightTurn90();

 			stopMotor();

 			clearEncoder();

 			driveForward(-564);

 			stopMotor();
}

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main ()
{
	int run = 1;
	while(run == 1)
	{
		if(vexRT[Btn8U] == 1)
		{
				StopTask(drive);
				stopMotor();
		}
		if(vexRT[Btn8D] == 1)
		{
				StartTask(drive);
		}
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
